Reflection and introspection
-----------------------
The Notebook for this lesson is named OOP Reflection Introspection.
In many objective languages, there are two special kinds of operations - introspection and reflection.
Introspection is the ability of a program to check the type of an object or the properties of an object
at runtime.
In other words, introspection allows you to get some information about a given object during the program Execution 

reflection is similar, but goes one step further.
It allows you to change the properties and methods of a given object during the program's execution.
Python allows you to do both introspection and reflection, and you actually already know most of the
tools that you need.

Suppose that you write a Python module that you believe will be useful for other programmers.
You want to create a function that accepts an object of any type of class, goes through all the properties
of the object, and for each string property it changes the property to an empty string.

We'll call this function empty_string because we want it to change all the strings into empty ones.
Normally such a function is impossible.
You don't know what kind of clusters your users will have.
You don't know what kind of properties these classes will have as well.
So how can you write such a function?

The answer is introspection and reflection.
Introspection will help you to get to know all the properties that are available for a given object
of any type of class.
Reflection, in turn, will allow you to change all these properties that you need.
Let's see how this can be achieved in practice.

So we'll create a method named empty_strings and it will have a single parameter user_object.
So this will be the object that we will want to introspect, reflect and change the strings into empty ones.

Now what we need to do, we are going to write a for loop in user object and here we will use the dict
property that you already know.
And because this is a dictionary, we are going to use the key method on it.
Now inside the loop we're going to do the following:
 - Prop_value will be a new variable that will equal getattr() with user object and prop_name 
as arguments and then if isinstance - this is also a new element here.

def empty_strings(user_object):
  for prop_name in user_object.__dict__.keys():
      prop_value = getattr(user_object, prop_name)
      if isinstance(prop_value, str):
         setattr(user_object, prop_name, '')

We get an object as a parameter, but we know next to nothing about it.
We don't know which class was used to create it.
However, we know that the built-in dict property is a dictionary that contains all the properties of
the object, no matter what kind of object it is.

Because it is a dictionary, we can actually use the case method.
This is a standard dictionary method to create a for loop.
This for loop will inspect all the properties of the given object one by one.
So, for each prop_name we use another function worth knowing - getattr().
It takes two arguments, an object and a name of its property and it returns the value of the given property.
Next thus isinstance(). Isinstance() takes two arguments.
 - The first one is a variable, the second one is a type 
isinstance() checks if the variable is of the given type, we put str here because 
we want to check for strings, but you could also put something like int for integers 
or maybe you could put a custom class name as well.

You can see that if the value of the given property is indeed a string,
We used the third new function setattr() - this function sets a new value for a given property.

In a given object, it takes three arguments the object, the name of the property and the new value.
Here we just set the new value to an empty string and that's it.

Let's see how this function will work with our doctor class

class Doctor():
  def __init__(self, first_name = 'John', last_name = 'Smith')
    self.first_name = first_name
    self.last_name = last_name
    self.__format_names()

  def__ format_names(self):
    self.first_name = self.first_name.title()
    self.last_name = self.last_name.title()

  def introduce(self):
    print('hi, i am', self.fist_name)

  def compare_name(self, name_to_compare):
    if self.first_name == name_to_compare:
      print('we have the same name')
    else: 
      print('sorry the name is different')

  def get_first_last_name_together(self):
    return self.first_name + ' ' + self.last_name

And now in the new cell we are going to create an object of the doctor class.
Let's say Alexander Smith will be the object.
Now, first of all, we want this doctor to introduce himself.
You can see that there is an introduce() method defined within the class and it simply prints the first
name.

doc_alex = Doctor('alexander', 'smith')
doc_alex.introduce()
empty_strings(doc_alex)
doc_alex.introduce()

output:
Hi, i am alexander
hi, i am

And now we want to run the function empty_strings() with this object as the argument, and we want the
doctor to introduce himself again.
Alex now has an empty first name, so the function correctly identified that there is a first name and
last name property.
And because both of them are strings, they were both set to empty ones.
And this is why the introduced method now returns an empty name.

==========================
OOP inheritance
---------------
Intro Inheritance is a big aspect of object oriented programming.
In certain situations, it can also get quite complicated.
Inheritance is a mechanism where one object or class is based on another object or class.
This way we can create super classes which are broader and more general, as well as subclasses which
are detailed and concrete.
A common example would be vehicles.
You could have a general class named vehicle, and you could then create more specific classes a land
vehicle or a water vehicle.
And then again, a land vehicle could be a car or a motorcycle.
A water vehicle, for instance, could be a boat.

In this hierarchy, we start with the broadest class definition vehicle.
Each land vehicle is a vehicle. Each water vehicle is also a vehicle.
And finally, a car. A motorcycle and a boat.

In this setup, we can say that, for instance, land vehicle is a super-class of car.
Vehicle is also a super-class of car. And car is a subclass of land vehicle.
Let's focus on these three for now. Vehicle, land vehicle and car 
will start by creating these three classes and they will be empty for now.

class vehicle:
 pass
class landvehicle(vehicle):
 pass
class car(landvehicle):
 pass

These three classes are messy.
And because Python doesn't allow empty blocks of code anywhere in such situations, we need to provide
at least a single instruction for each class.
So now this instruction will be pass, which means do nothing that effectively gives us empty classes.

So what's the new element here?
Note that landvehicle has a pair of brackets after its name.
In the brackets we provide the name of the superclass, which is vehicle.
The same goes for call in the brackets.
We provide the name of the landvehicle.

This way Car has become a subclass of LandVehicle and LandVehicle has become a subclass of vehicle.
We can check that using python's is subclass() function.

issubclass(car, landvehicle)
True
issubclass(landvehicle, vehicle)
True

In our case, a car is also a subclass of vehicle, even though not directly.
Interestingly, a car is also always a subclass of itself.
issubclass(car, car)
True

==========================
inheritance properties
---------------
now that we know the hierarchy of classes, let's add content to the three classes to see how
inheritance really works.
We can create a car object like this.

class vehicle:
 pass
class landvehicle(vehicle):
 pass
class car(landvehicle):
 pass

my_car = Car()
print(my_car.__dict__)
output: {}

The classes don't have any constructors defined, they don't contain any properties.
And so you can see that we create a car with no arguments passed in the brackets.
When you check the dict property for the object created, it is empty.

Now let's add a constructor to the top hierarchy vehicle class.
So we are going to create a new cell.

class vehicle:
 def __init__(self, speed):
  self.speed = speed
class landvehicle(vehicle):
 pass
class car(landvehicle):
 pass

And now let's try to create the object again.
And now when you want to run the code, it fails.

my_car = Car()
print(my_car.__dict__)
output: err line 1 missing required positional argument 'speed'

The constructor is missing one required positional argument named speed.
How is that possible?
We don't have any constructor or any property defined in the car class.
If we don't define a constructor for car explicitly, Python will try to look for a constructor in all
of these super classes.
There's no constructor in land vehicle, but there is one in vehicle, so Python will use that constructor
for creating costs.

All of this happens because car inherits from land vehicle which in turns inherits from vehicle.
All the properties and methods defined in vehicle will therefore be visible in car.
This means that we now need to provide an argument for the speed parameter in the car subclass such
as here.

As you can see, car inherited the speed property from the vehicle superclass.
All of this happens indirectly through the landvehicle class.
Now what happens when we create a constructor in the landvehicle in turn?

class vehicle:
 def __init__(self, speed):
  self.speed = speed
class landvehicle(vehicle):
 def __init__(self, wheel_count):
    self.wheel_count = wheel_count
class car(landvehicle):
 pass

And now if we try to create an object in the very same manner 
something strange happened here, we could successfully create an object of class car, 
but the speech property from the vehicle constructor is gone.

my_car = Car(5)
print(my_car.__dict__)
output: {'wheel_count': 5}

The rule is that Python only inherits the constructor from the superclass if there is no constructor
defined in the given class.
In the previous example here, car didn't have a constructor, so it inherited a constructor from Land
Vehicle and because LandVehicle did not have a constructor either, it inherited the constructor defined
in the vehicle class.

As a result, the constructor from vehicle was used to create a car object.
And here when we defined a constructor in landvehicle, it did not inherit the one for vehicle.
That means that landvehicle has its own constructor now, which is not related to the vehicle constructor
here in any way.

And this time Car inherited this new constructor for a land vehicle which doesn't have a speech property.
inheritance allows subclasses to take properties from the super classes.
But here it looks like car only has the properties from their land vehicle, but it doesn't have the
property from their vehicle.

How to change that?
All we need to do is invoke the vehicle constructor from the landvehicle constructor directly.
I'm going to add the following vehicle in it.
And this constructor expects two parameters.
So I'm going to do a self and speed.

class vehicle:
 def __init__(self, speed):
  self.speed = speed
class landvehicle(vehicle):
 def __init__(self, wheel_count):
  Vehicle.__init__(self, speed)  
  self.wheel_count = wheel_count
class car(landvehicle):
 pass

And now, because I need to value for a speed, I'm going to add it here as one of the parameters around
the cell.
And now let's try to create a new car object with two arguments.
As you can see that it succeeded as the first instruction in the land vehicle constructor.

my_car = Car(5, 10)
print(my_car.__dict__)
output: {'speed': 5, 'wheel_count': 10}

The name of the superclass followed by adult and the init method name.
We can see in the vehicle constructor definition that it requires two arguments, self and speed.
So these are the arguments that we provide insight the land vehicle constructor.
The first one is self and the second one is speed.
For speed to work, we had to add another parameter to the Land Vehicle constructor here.

The constructor now has three parameters.
The first one is self, the second one is speed, and the third one is wheel_count and this version
will be inherited by the car.
This also means that to create a car object, we need to provide two parameters one for speed and the
other one for wheel_count.
And as usual, the self reference is provided for you automatically.

So in short, to invoke the constructor from the superclass, we can use the dot notation with the name
of the superclass, but we can also do something else.
We can use a special super keyword

super().__init__(speed) # we replaced   Vehicle.__init__(self, speed)  
it works in the very same way.

Note a subtle difference when we use the super keyword instead of the super class name, we don't need
to provide the self parameter.
It will be automatically passed for us by Python to a superclass constructor.
Both notations, the one with the class name and the one with the super keyword allow you to use constructors
from super classes.

This in turn means that we can inherit instance variables from super-classes outside the class definition.
We can simply use the dot notation to access the instance variables defined in the super-classes.
So here when we have a my_car object, we can do the following speed and you can see that it works.
So this value is actually taken from the super class named vehicle, even though we never defined a
speed instance variable in the car class, it was inherited for us from the super classes via constructors.

==========================
inheriting class variables and methods
---------------

class vehicle:
 class_message = 'this is a message from the vehicle class!'
 def __init__(self, speed):
  self.speed = speed
class landvehicle(vehicle):
 def __init__(self, wheel_count):
   super().__init__(speed)
   self.wheel_count = wheel_count
  print(vehicle.class_message) # this can be replaced with print(super().class_message)
class car(landvehicle):
 pass

We already know how instance variables can be inherited using constructors, but how about class variables?
It turns out that they work exactly the same way, and it turns out that you can use the same syntax
to get them.
In this upper class vehicle, we are going to write a class message and let's say it's going to be something
like this is a message from the vehicle class.
And now we want to print that class message at the end of the constructor in the subclass names LandVehicle.
So we are going to do the following print vehicle Class Message.

In order to verify whether that works, we're going to create a new my_car.
And let's see what this cell does when we run it.

my_car = Car(50, 4)
output: this is a message from the vehicle class!

It actually creates the object based on the constructor from the land vehicle class.
And it also prints the message from the superclass named vehicle.
So here we defined a class variable in the vehicle class and we could then easily access this variable
in the subclass using the dot notation with the superclass name.

Outside the class definition, we can easily access the class variable from vehicle using the dot notation
too so we can do something like this:
my_car.class_message

The class variable was inherited from the super-class and we can access class message from a car object
as you can see.

Now, how about methods from super classes?

Exactly the same story.

Take a look here.

We are going to copy paste this into a new cell and I'm going to add a new method here in the land of

equal death, speed up self, self speech plus equals five.

And now in the call class, we're going to do death super speed self and it's going to print super speed,

activate it first, and then it's going to do super speed up.

And we're actually going to repeat that three times around the cell.

And now let's create a new object.

My first call equals call.

Let's say ten and ten.

Sorry, just four wheels.

Let's print the dict variable.

My fast car dict.

Then we are going to call it again.

And between these invocations, we are going to do my fast car super speed.

Let's see what this will do.

And you can see the speed has changed.

Look how we added a speed up method in the land vehicle superclass.

Then in the cost subclass we created a super speed method where we invoke this method three times in

a row.

Again, we can use the super keyword or we can use the class name.

So you can choose land vehicle in here.

If we don't want to speed up so aggressively with our mycar object, we can of course also use the speed

up method directly.

This method is automatically inherited from the parent class, so you can do something like my fast

car, speed up just like this, and then let's print the content of dict after that and you can see

again it worked.

And that's it for this video.

As you can see with multiple levels of inheritance, it can sometimes get quite complicated to see what

is inherited, where and how to invoke it.

Don't worry if you didn't understand everything after watching this video, all the previous ones,

try watching them again and post them whenever you don't understand something.

You can also always ask a question in the Q&A section if you need additional help, and I will be eager

to help you.
