OOP Intro
==================
You may not need to use object oriented programming yourself, but you may need to use some Python modules
that are written to utilize objects.
So far, nearly everything we wrote in Python was classified as procedural programming.
Procedural programming was a widely used approach to writing code for decades, and it's still in use
today in some situations.
It is the best choice for many types of projects in general.
If you're looking to write a smaller Python program quickly, the procedural approach may be the best
choice.
The basic idea behind procedural programming is that we have procedures.
Procedures in the Python language would be functions.

Functions simply have a series of steps to be carried out while you write a program in Python, any
function can be invoked at any point.
You can even make one function, call another one.
Functions in this approach typically work on data, so the whole procedural approach is about calling
functions that do something with data.
One of the problems with procedural programming is that there are no restrictions.

Any function can call any other function and the functions can work on any tighter.
For instance, someone may provide you with a function that converts temperature decrease from Celsius to Fahrenheit.
The function is meant to work on numbers that represent temperature, but if you instead provide the
function with a bank account number, it will also work.
It's just that the result of this function will not make much sense.

Object oriented programming tries to eliminate such problems.
This programming technique is much younger than procedural programming, but is the standard approach for most big 
applications nowadays in object oriented programming, data and functions are enclosed together, forming something called objects.
An object is a structure that has some data in the form of traits.

These traits are called properties, attributes or fields in the world of programming.
Objects are also able to invoke some functions in the form of methods in programs that use object oriented programming.
Objects interact with each other, exchange data, or call each others methods.

Suppose that we need a program that asks the user for the width and height of a rectangle.
Then the program calculates the area of that rectangle.

In procedural programming, we can do something like this.
here we defined a function named calculate area.
This function takes two arguments width and height and returns the width multiplied by the height,
which is the area for the rectangle.
Finally, the area is shown to the user here.

def calculate_area(width, height):
  return width * height

width = int(input('what is the width? '))
height = int(input('what is the height? '))
area = calculate_area(width, height)
print('the area is', area)

As we said, one of the disadvantages of the procedural approach is that the functions that we define
know nothing about the data.
We could ask the user for their age and pass that age as the first argument of the function.
The function would still work and to produce something that doesn't really make sense.
But because the function and the data are not tied together in any way, the function doesn't know that.
It just does what it is asked to do.

If we input 10 and 3, it would result 30.

def calculate_area(width, height):
  return width * height

width = int(input('what is the width? '))
height = int(input('what is the height? '))
area = calculate_area(width, height)
print('the area is', area)

age = int(input('hey, and what is your age? '))
strange_operation = calculate_area(age, height)
print('your age multiplied by the height is', strange_operation)

But now take a look at this code, which is similar.
But after we calculate the area, we also ask for the age and we do a strange operation.
We calculate the area by providing the age and the height.
So you can see that the function works fine, even though we passed an argument that doesn't make much sense.
Now let's take a look at the object oriented approach.

class Rectangle:
    def __init__(self, width, height):
      self.width = width
      self.height = height # class definition (template for creating rectangles)

    def get_area(self):
        return self.width * self.height

a = int(input('what is the width? ')) # So here we ask the user to provide a width and height here down below.
b = int(input('what is the height? '))

rectangle = Rectangle(a, b) # we create a new rectangle object with the width and the height that we got from the user.
print('the area is', rectangle.get_area())

Just try to get the general concept for now.
So in the object approach, this would look something like this.
All you need to know is that this part of the code is a class.

A class is a template for creating objects of the same type.
Our class is named Rectangle and it allows us to create rectangle objects.
When we create the objects, we provide the height and the width.

Then using the code like here we create a new rectangle object with the width and the height that we
got from the user.
From this moment on, Python keeps in memory an object, a structure, a rectangle with a specific width
and a specific height.
The width and the height are tied together.
They are no longer two separate variables, like in their procedural approach.
Instead, they are kept together.

Of course, you could argue that the procedural approach allows us to keep the width and the height together too.
You could, for example, put them into a tuple, into a list or into a dictionary, and you would achieve
a similar result.
But the difference here with the object is that the object not only has the width and the height, it
also has its own function defined within the class get_area.

This function can be used to return the area of this specific rectangle, not any rectangle, but only
this specific rectangle that we created.
You can no longer try to provide the age of the user as one of the arguments.
In fact, there are no arguments when we call the method here.
The method only works in the context of the specific rectangle, and it only works on this specific
object, this specific rectangle with this specific width and this specific height.

And if we run the program now, we can see that it works in the very same way.
But the structure is a bit better.
At first, you could say that there is not much difference between these two approaches.
So the object approach here and the procedural approach here.
You can only say that the object approach looks more complicated than the procedural approach.
It uses some new fancy keywords that you don't know yet, and it generally seems over complicated.
You still get the area of a rectangle by multiplying the width by the height.
you could see that the actual logic that the actual area calculation is the same.
You multiply two numbers by themselves here and you multiply two numbers by themselves here.
So why bother creating a rectangle object from a rectangle class?

Just as I said, the procedural approach is still in use and it is sometimes the best option, typically
in smaller applications, because it's very simple and quick to write.
But, when you start creating bigger applications, when you start working on the code with
other people and you have hundreds or thousands of functions, it's very easy to get lost. 
With bigger applications, People tend to use functions in the wrong way.
They either use functions that are not meant to be used at all, or they use functions with the wrong kinds of arguments.
The end result is chaos.

Object oriented approach allows you to organize this case with objects.
You clearly define what types of data is used in your application.
It is also clearly defined what you can do about the various kinds of data.
The extra effort that you need to put into designing and creating objects really pays off in bigger applications.

---------------------------
Classes and objects
==================
Even though we talk about object oriented programming, objects in Python can't exist without classes.
Classes are templates used to create objects.
For example, you can create a class named user.
Classes can contain two types of entities - variables called attributes and functions called methods.

In our simple example, we'll say that each user is characterized by a username and a city.
Each user is also able to introduce themselves.
So we will create a method named introduce.
This gloss will serve as a template to generate specific uses.
You could then have a specific user with username motorknight New York City.
Then you can create another user named Ruler of Darkness London.

These specific users, created on the basis of the user class, are called objects.
Objects contain the attributes and methods specified in the class, so we know that each user object
has a nickname and a city, and we also know that each user object can invoke the introduce method to introduce itself.
This is true at the moment when we create an object because later on we can change the properties and
methods in the object, but we'll get to that later on.

So that's the main difference between classes and objects. Classes are templates used to create specific objects.
We sometimes use the term instantiate. We instantiate objects from classes.
We can also say that objects are instances of the class.
You can't create objects if there is no class, but you can create a class and then never instantiate an object from it.
In other words, a class is an idea which can be used to create specific inclinations called objects.
Each object has a name, a set of properties and a set of methods.

It's time to create the use of class in code and see the syntax when defining class.
We always start with the class keyword followed by the name of the class and the colon by convention.
Class name starts with capital letters.
Class names typically only use letters with no digits or special characters like I have here.
Each class has its own block of code after the colon.
As with any other block of code, you need to use indentation for that.
Now, as we said before, we want each user object to have a username and a city.
If we want to have that, we need to make use of a special function, a special method inside the user class.

This method is generally called constructor because it is used to construct objects of a given class.
The constructor definition needs to begin in a very specific way.

Take a look def init self.
The constructors name is always __init__.

class User:  
  def __init__(self):

If you use any other name, Python will not treat that method as a constructor and it will not use it
to construct new objects.
Just like with any other function in Python, you need to precede the function name with the keyword def.
After the name you need to provide a pair of brackets and provide the arguments.
Finally, you need to add a colon. You may be wondering what this self parameter is.

All Python constructors must have at least one parameter.
It is absolutely obligatory for a constructor to have it.
You can give it any name that you want, but the convention that you should always follow is self.
This self parameter is always pointing to the object that you are currently creating within the constructor.

We want each object of the user class to have two attributes username and asset.
Remember that attributes are just variables in classes.
So inside the definition of in it we're going to write self dot nickname equals sample nickname and
then below self city equals sample city.

class User:  
  def __init__(self):
    self.nickname = 'sampleNickname'
    self.city = 'sampleCity'

In order to inform Python that each object created from class User we should have two properties nickname
and city, we need to use the self argument inside the constructor and provide the name for the attributes 
after single dots.
In general, we use dots in Python objects to refer to the attributes and methods of that object.
This way we are telling Python. Whenever you create a user, give them two properties - Nickname and City.

For now, you can see that each user created from this class will have the same nickname, samplenickname
and the same city - sampleCity.
This definition only tells us that there will be two properties or fields in each user object - nickname
and a city.

Now we also mention that each user should be able to introduce themselves.
In order to do that, we need to create another function inside the user class.
Remember that a function within a class is called a method.

class User:  
  def __init__(self):
    self.nickname = 'sampleNickname'
    self.city = 'sampleCity'
  def introduce(self):
    print('Hello, I am', self.nickname, 'and I live in', self.city)

This time we are not creating a constructor so we can give the function any name that we want.
In this case introduce.
We again use the self parameter here and again this self parameter refers to the current object.
Thanks to it we can use self.nickname and self.city to access the variables or in other words, the
properties of the current object.
Again, we use dots to access specific attributes of the object.

So it's time to create our first object from this class user.
Down here, after the class definition with no indentation will write sample user.
This will be our variable and we'll write user with a pair of brackets.
We create a variable named sample_user just like we always do with any other kind of variable.

class User:
  def __init__(self):
    self.nickname = 'sampleNickname'
    self.city = 'sampleCity'
  def introduce(self):
    print('Hello, I am', self.nickname, 'and I live in', self.city)
sample_user = User()

After the assignment operator, however, we do something new, we provide the name of the class followed
by a pair of empty brackets.
Whenever we provide a name of an existing class and we put a pair of brackets afterwards, Python knows
that it should create a new object from the class.
And how does it do that? By calling the constructor.
In the constructor, we instructed Python to create two variables inside the object, nickname and City.

Even though the constructor has a parameter called self defined here.
We do not provide a value for that parameter when creating an object of the class.
That first argument of the constructor is filled for us automatically and it will always contain a reference
to the object which is being created.
So even though it looks like the constructor requires a single value for the self parameter, in reality
we don't provide anything when we create the object.

Right now that we have a sample user, one thing that we can do is call it introduce method to see how
that works.
To do that, we use the same dot notation on the sample user variable.
So sample user dot introduce and a pair of brackets.

So in order to call a method and an object, we need to provide the variable in which the object is stored.
Then we need to use a dot and after the dot we need to provide the name of the method followed by a
pair of brackets.

class User:
  def __init__(self):
    self.nickname = 'sampleNickname'
    self.city = 'sampleCity'
  def introduce(self):
    print('Hello, I am', self.nickname, 'and I live in', self.city)
sample_user = User()
sample_user.introduce()

Output: Hello, I am sampleNickname and I live in sampleCity

So, again, even though there is a self parameter here defined in this introduced method, this very
first parameter is always provided by Python for us.
So we don't have to provide it when we call the method here.
And you can see that Python prints an introduction statement for us and it uses the nickname and the
city of the given object.

You can also inspect what is hidden in the properties or the fields of the given object.
That's no matter if you want to access an attribute or a method inside an object, you use the dot notation.
The only difference is that accessing methods requires the use of square brackets like here, just like
with any other function in Python.

print(sample_user.nickname) 
print(sample_user.city)
Output: sampleNicknname  sampleCity

And remember that when you create an object from a class, you use the class name followed by a pair
of brackets and here python will know to call this specific method named double underscore init - which
is the constructor.

In particular, all the users have the same nickname, sample nickname and the same city.
We would like to provide our own values in the constructor when we create user objects.

So we'll create a new version of this class here and will do the following.
So we'll add two parameters here usernickname and UserCity.

class User:
  def __init__(self, user_nickname, user_city):
    self.nickname = user_nickname
    self.city = user_city
  def introduce(self):
    print('Hello, I am', self.nickname, 'and I live in', self.city)
sample_user = User()
sample_user.introduce()

And now, instead of the default values, will do the following.
As you can see, we simply add two new parameters to the constructor and we can then use these parameters
inside the constructor to create the properties of the object.
The parameter names can have well any name that you want, just like with any other function in Python.
One interesting thing is that the parameter names can be even identical with the fields in the object.
You can use nickname and you can use set a and then set it like this.

This may look a bit weird because it looks like the same variables really, but they're actually different.
The self.nickname variable refers to the property of the object and the nickname variable without
the self prefix is the argument passed to the constructor.

class User:
  def __init__(self, nickname, city):
    self.nickname = nickname
    self.city = city
  def introduce(self):
    print('Hello, I am', self.nickname, 'and I live in', self.city)
sample_user = User('DarkKnight', 'Heaven')
sample_user.introduce()
print(sample_user.nickname)
print(sample_user.city)

Now you can see that our user has the exact nickname and city that we provide it in the bracket when
we created the user.
Again, note that the constructor has three parameters self, nickname and city, but we only provide
two parameters when we create the object.
That's because the first argument is the reference to the object being created and Python provides that
automatically for us.
Once we create a class, we can instantiate many different objects from it.
Let's create two more users here.

first_user = User('Martin', 'Luther')
second_user = User('Winston', 'Churchil')
third_user = User('Willie', 'King')

So now we have three new users first user, second user, and third user.
And now we can do first user introduce than second user introduce and third user introduce.

first_user.introduce()
second_user.introduce()
third_user.introduce()

And you can see that all three objects have a methods named introduce because all of them were created
based on the class.

---------------------------
Encapsulation and abstraction
=============================
All right, let's create a new simple class now.
The class will be called car.
It will be a very simple class that describes a very generic column.
It will have three properties modal color and current speed.
So we'll start by creating a constructor for this class.
As we said before, the constructor must always have a special name. Double underscore in it.

class Car()
  def __init__(self, model, colour, initial_speed)
    self.model = model
    self.colour = colour
    self.speed = initial_speed

  def speed_up(self):  
    self.speed += 5

  def slow_down(self):  
    self.speed -= 5

  def show_speed(self):  
    print('current speed', self.speed)

my_lovely_car = Car('T-roc', 'red')
my_lovely_car.speed_up() 
my_lovely_car.speed_up()
my_lovely_car.show_speed() 

output: 
Current speed: 10

The first argument is by convention name to self and to references the object that is being created.
The next three arguments are the model color and the initial speech of the car.
These three arguments will be provided by the user of the class when they create new car objects.
So let's run the cell and now we'll create new car objects.
And when you run the code, you can see that everything works fine.

Now do you remember how to provide default values for function parameters?
Turns out that it works with constructor and other methods within classes too.

And now every car that is created without providing an initial speed will be given the default value
of zero.
So now it's possible to create a new car using one argument less and Python will fill that automatically
for us.
Let's try it out so we'll delete the initial speed and everything works like a charm.

Our class is defined, but it doesn't do anything useful yet.
We'll add two new methods to the class that will make the class speed up or slow down.
Def speed up self self speed plus equals five and the similar method def slow down self self speech
minus equals five.
each method in your class should contain a single parameter at least, which is by convention named self.
This argument allows you to access the object's properties and increase or decrease the speed by five
respectively.
All right, we'll add one more method that will present the current speed to the user.
So we'll do def show speed self and it will do print current speed and after a comma cell speed round
the cell.
We can see the speed of ten.

If the current speed is zero, it shouldn't be possible to slow down.
So instead of speed up we'll do slowed down after creating the object and will do that actually twice.
And you can see that the current speed is minus ten.

my_lovely_car = Car('T-roc', 'red')
my_lovely_car.slow_down() 
my_lovely_car.slow_down()
my_lovely_car.show_speed() 

output: 
Current speed: -10

We should modify our code so that it doesn't decrease the speed below zero.
Fortunately, that's pretty simple.
So in the slow down method, we're going to do the following if cell speed is slower than five.
Self speed equals zero.

class Car()
  def __init__(self, model, colour, initial_speed = 0)
    self.model = model
    self.colour = colour
    if initial_speed < 0
      self.speed = 0
    else:
      self.speed = initial_speed

  def speed_up(self):  
    self.speed += 5

  def slow_down(self):
    if self.speed < 5
      self.speed = 0
    else:
      self.speed -= 5

  def show_speed(self):  
    print('current speed', self.speed)

my_lovely_car = Car('T-roc', 'red', -50)
my_lovely_car.speed_up() 
my_lovely_car.speed_up()
my_lovely_car.show_speed() 

output: 
Current speed: 0

If we now run the program, we can see that the speed never goes below zero.
But there's one more problem.
What happens if the user provides a value below zero when they create a call?
So instead of the two argument version and the default value of zero for this speech, we're going to do the following -50.
And now if we try to show the speed without slowing down or speeding up, you can see the value of -50.
Well, that doesn't make much sense either.

We need to also modify our constructor so that it doesn't allow speech values below zero.
One way of dealing with that could be as follows.
After setting model or color, we can check if initial speed below zero then self speed should be equal to zero.
Else it should be equal to the argument passed around this cell and now run this one.

And you can see that even though we provided a value of -50, the current speed is actually zero.
So the constructor modification worked fine.

If the user creates the car with a speech value below zero, we will simply put zero as the initial value.
Our class is now almost bulletproof in terms of speed, but unfortunately, there's one more way that
the user may try to hack our class.

Use case:
my_lovely_car = Car('t-roc', 'red', -50)
my_lovely_car.speed = -10
my_lovely_car.show_speed()
output: -10

As you can see, the user can simply access the speech property directly using the dot notation and
set any speech value that they want.
What can we do about it?
The user does not call any method defined in the clause, so there is no place where we could add some
checks for speeds below zero.
Luckily, there is a way to kind of stop the user from changing the speech property directly.
We need to make the property private.
A private property is a property that can only be accessed from within the class.
In one of the methods, but never outside the class after the object is created.

So in the properties private, you can't do an operation like this.
Different programming languages implement the concept of private properties differentially in Python.
If you want a private property, you need to give it a name that starts with two underscore signs.

So we'll need to do a lot of refactoring now in the class itself.
So take a look here instead of speed will do to underscore speed.
Same here, here and in all the places.
Let's run the class and now let's run this cell.

class Car()
  def __init__(self, model, colour, initial_speed = 0)
    self.model = model
    self.colour = colour
    if initial_speed < 0
      self.__speed = 0
    else:
      self.__speed = initial_speed

  def speed_up(self):  
    self.__speed += 5

  def slow_down(self):
    if self.__speed < 5
      self.__speed = 0
    else:
      self.__speed -= 5

  def show_speed(self):  
    print('current speed', self.__speed)

my_lovely_car = Car('T-roc', 'red', -50)
my_lovely_car.speed = -10
my_lovely_car.show_speed() 

output: 0

And you can see the current speed of zero.
Now, with the double underscore in front of the property, the code works fine.
We couldn't change the value of the speech property, as you could see, and the speed was still zero
after this line.

Incidentally, there are four main principles behind object oriented programming in most modern programming
languages encapsulation, abstraction, inheritance and polymorphism.
These names may sound scary to you, but don't worry, we'll explain them over time 
in this video the usage of private properties mainly addresses the concept of encapsulation, and encapsulation says
that objects should keep their state private and only expose a set of public functions to the outside world.
We made the speech property private, so we heard the state of the object from the outside world and
we exposed two methods speed up and slow down to manipulate the property in a way we previously defined.

This also shows the second principle behind object oriented programming.
Abstraction says that objects should keep the details of how they work to themselves and only expose
some high level operations to the outside world.

----------------------
Instance variables
===============
Here we've got a simple class named Doc.
In its constructor, we create to properties, name and age.
This kind of property exists when it is created explicitly and to add us to an object.

class Dog():
  def __init__(self, name, age):
    self.name = name
    self.age = age

One way to do that is during the object's initialization in the constructor as shown in the example.
However, once you create an object, Python allows you to add new properties or even remove existing ones.
We are going to run this cell and create a new object.

my_pet = Dog('Teddy', 2)
my_pet.colour = 'brown'

Let's say Teddy with the age of two and now we are going to do my pet dot color equals brown.
We have just added a third property to the object.
Even though the dog class has only defined two properties for created objects, name and age, we are
able to add a third one using the dot notation.

The My Pet Object now has two properties from the constructor. Name and age.
And a third property added to manually later in the code.
We're going to create a new cell and run:

del my_pet.name

We are also able to delete any existing property and now the My_Pet Object only has one of the two properties
defined in the constructor.
The second one name is gone.

Instead we have a brand new property that was not defined in the constructor color.
First of all, you must be aware that different objects of the same class can have different properties.
And second of all, each object has its own set of properties with its own values.
The properties of one object don't interfere with the properties of another object in any way.
In general, such properties are called instance variables.
An instance is another name for an object. This indicates that instance Variables are variables closely related to a specific object.
Then you may ask if I can dynamically add or delete instance variables of an object.
How do I know which instance variables are available in a given object in a given place in the code?
Luckily, there's an easy way to check that.

Objects created in Python are automatically given a few useful properties and methods.
One of them is a dictionary named __dict__
Let's see what it contains in a few places in this code.

my_pet = Dog('Teddy', 2)
my_pet.__dict__
output: {'name': 'Teddy', 'age':2}

As you can see, the dictionary under the name dict shows all the currently available properties.
You can see how the dictionary changes when we add or delete a property.

my_et.colour = 'brown'
my_pet.__dict__
output: {'name': 'Teddy', 'age':2, 'colour': 'brown'}

del my_pet,name
my_pet.__dict__
output: {'age': 2, 'colour': 'brown'}

Keep in mind that you can use the dict instance variable with any object that you create.
Python automatically adds this for you.
But now let's say that we want to make one of the properties private.
In programming, private properties are properties that are not accessible from outside the class.

class Dog():
  def __init__(self, name, age):
    self.__name = name
    self.age = age

my_pet = Dog('Teddy', 2)
print(my_pet.__dict__)

output: {'_Dog__name': 'Teddy', 'age': 2}

We don't have the double underscore name property at all.
Instead, we have another one with a very strange name. Underscore dog, double underscore name.

Where does it come from when Python sees that you want to add a private property with two underscore
signs in front of it?
It uses the so called name mangling to mangle in English means to destroy something or twisted terribly.
And that's kind of what happened here.
Your nice little double underscore name variable becomes underscore dog, double underscore name.
In other words, you get an additional underscore sign and the class name before the actual name of
the private property.

So even though you can use the name, double underscore name inside the class definition, when you
try to do that outside the class, you get an error.

print(my_pet.__name__)

You can see an attribute error.
The property is not accessible because there is no such property.
Its name has been changed to underscore Dog Double and the school name outside the class.

But hey, does that mean that you can use that strange name outside the class definition to access the
private property? Yes, you can.
So we can change this to the following here.

print(my_pet._Dog__name)

You have just access to property outside the class, even though that property was supposed to be private.
As you can see, making a property private in Python is limited.
Someone can still access the property outside the class if they really want to.
They can use that strange, mangled name that Python creates.
In the end, we need to treat the double underscore prefix more as a warning.
It means that the creator of the class believes you should not modify the given property directly,
but formally speaking, there's no way to stop someone from doing it.

This name mangling only works if you use the double underscore prefix inside the class.
If you try to add a property later in the code outside the class, mangling will not work.

my_pet.__breed = 'Bulldog'
print(my_pet.__dict__)
output: {'_Dog__name': 'Teddy', 'age': 2, '__breed': 'Bulldog'}
My pet dict, you can see that this time name mangling didn't work because we used the double underscore
syntax outside the class code.

-----------------
Class variables
================
A class variable is a property that exists in just one copy.
It is stored in the class itself.
But outside any object, a class variable exists, even if you don't create any object of that class.
Take a look at the sample code.

class Dog():
  counter = 0
  def __init__(self, name, age):
    self.__name = name
    self.age = age
    Dog.counter += 1
my_pet = Dog('Teddy', 2)
kates_pet = Dog('Foxy', 5)
adams_pet = Dog('Luna', 5)

print(my_pet.counter)
print(kates_pet.counter)
print(adams_pet.counter)

We've created a new variable inside the class counter.
The aim is to have a variable that will count how many objects of the class were created.
Note that this variable is defined in a different way than the name and age.
Variables, name and age were defined inside a constructor here with the reference to self, but the
counter was defined with no reference to self outside the constructor.

This makes it a class variable, not an instance variable.
Apart from that, when you want to make a reference to this variable inside the class code, you need
to use the class name followed by a dot like here.
This code adds one to the counter whenever the constructor is used.

In other words, whenever we create a new object, the counter is increased by one outside the class.
We can reference the class variable just like any instance variable using the dot notation.
But note how this class variable has the same value in all three objects now that we run the code.

output:
3
3
3

You can see that the value of counter is the same in all three objects.
That's because there's always exactly one copy of a class variable that is shared across all objects.
What's more, if you try to use 

my_pet.__dict__
output: {'_Dog__name': 'Teddy', age = 2}

you will not see the counter class variable.

That's because dict only shows instance variables and ignores class variables 
to see which class variables are available, you need to take a look at the definition of the class itself here.
So that's one way of accessing a class variable.

But what if you haven't created any objects or you don't have one at hand?
You can still access class variables using the class name itself
Both versions retain the same class variable value.

print(Dog.counter)
output: 3

I personally prefer the second approach where you provide the name of the class, not the name of one
of the objects.
To me it's much clearer and shows that the variable belongs to the class itself, not to any of the objects.
You can also make class variables private, just like with instance variables.
The effects will be identical.
The name of the class variable will be mangled but still accessible outside the class definition.

class Dog():
  __counter = 0
  def __init__(self, name, age):
    self.__name = name
    self.age = age
    Dog.counter += 1

print(Dog._Dog__counter)
I've mentioned that you can use the dict variable to see the instance variables for any object created.
It turns out that there's also a class variable with the same name.
Take a look how to access it.

print(Dog._Dog_counter)
output: 0

print(Dog.__dict__)
output:{...}

As you can see, the class of variable named dict contains much more data than the instance variable named dict.
There are some strange elements here that you've not seen before.
Most importantly, however, you can see the mangled counter here.
You've seen a lot of examples for class variables and instance variables.
You also know that we can add or remove properties on the go.
As a result, you can never be sure if a given object contains a specific property.

One way to check that, of course, is to use the dict variable.
But you can also use a special function named hasattr().
We are going to copy paste the previous definition, put it here and now will create a new object.

class Dog():
  __counter = 0
  def __init__(self, name, age):
    self.__name = name
    self.age = age
    Dog.counter += 1

my_pet = Dog('Tom', 5)
if hasattr(my_pet, 'name')
  print('my pet is called', my_pet.name)
else:
  print('my pet has no name')
output: my pet has no name
===============================
class Dog():
  __counter = 0
  def __init__(self, name, age):
    self.name = name
    self.age = age
    Dog.counter += 1

my_pet = Dog('Tom', 5)
if hasattr(my_pet, 'name')
  print('my pet is called', my_pet.name)
else:
  print('my pet has no name')
output: my pet is called Tom

So you can see my pet has no name shown to the output because name is actually private.
Now if we switch it again to a public property, you can see my pet is called Tom.
The function has other excepts to arguments.
The first one is the object or a class.
The second one is the name of the property.

In this example, we first invoke the function when the object has the property defined as private,
and then we make the property public and invoke the function again.
The output is different in both cases.
You can also use the same function to check if a class has a class variable.

if hasattr(Dog, 'name')
  print('the dog class has a counter', my_pet.name)
else:
  print('the dog class does not have a counter')
output: The dog class has a counter

So you can see that now, instead of providing an object, I actually provide the name of the class
and you can see that this code works as well.

We've talked about the built in property dict, but it's not the only one available in all objects.
Another built in property is name.
It is much less exciting than dict because it only returns the name of the class.
What's more, it can only be used with a class name, not with an object name.

print(Dog.__name__)
output: Dog

There is, however, one useful use case.
If you combine the name property with the type function, the type of function returns the type of the
given variable.
It could return something like integer string or the class that was used to create an object.
Now we're going to create a new pet and now we are going to do type of my pet and then name.

So using the combination of type and name, you can actually output a string which will contain the
name of the class used to create the object.

my_pet = Dog('Tom', 5)
type(my_pet).__name__
output: 'Dog'

The last built in property worth mentioning is module.
It returns the name of the module that contains the definition of the class.
You can use it with both objects and classes.
The result will be the same if the class is defined in the same file.
You will instead see main.
So here we can do a print dog module and you can see Main because the dog class has been defined in
the very same notebook.

print(Dog.__module__)
output: __main__
