OOP Intro
---------
You may not need to use object oriented programming yourself, but you may need to use some Python modules
that are written to utilize objects.
So far, nearly everything we wrote in Python was classified as procedural programming.
Procedural programming was a widely used approach to writing code for decades, and it's still in use
today in some situations.
It is the best choice for many types of projects in general.
If you're looking to write a smaller Python program quickly, the procedural approach may be the best
choice.
The basic idea behind procedural programming is that we have procedures.
Procedures in the Python language would be functions.

Functions simply have a series of steps to be carried out while you write a program in Python, any
function can be invoked at any point.
You can even make one function, call another one.
Functions in this approach typically work on data, so the whole procedural approach is about calling
functions that do something with data.
One of the problems with procedural programming is that there are no restrictions.

Any function can call any other function and the functions can work on any tighter.
For instance, someone may provide you with a function that converts temperature decrease from Celsius to Fahrenheit.
The function is meant to work on numbers that represent temperature, but if you instead provide the
function with a bank account number, it will also work.
It's just that the result of this function will not make much sense.

Object oriented programming tries to eliminate such problems.
This programming technique is much younger than procedural programming, but is the standard approach for most big 
applications nowadays in object oriented programming, data and functions are enclosed together, forming something called objects.
An object is a structure that has some data in the form of traits.

These traits are called properties, attributes or fields in the world of programming.
Objects are also able to invoke some functions in the form of methods in programs that use object oriented programming.
Objects interact with each other, exchange data, or call each others methods.

Suppose that we need a program that asks the user for the width and height of a rectangle.
Then the program calculates the area of that rectangle.

In procedural programming, we can do something like this.
here we defined a function named calculate area.
This function takes two arguments width and height and returns the width multiplied by the height,
which is the area for the rectangle.
Finally, the area is shown to the user here.

def calculate_area(width, height):
  return width * height

width = int(input('what is the width? '))
height = int(input('what is the height? '))
area = calculate_area(width, height)
print('the area is', area)

As we said, one of the disadvantages of the procedural approach is that the functions that we define
know nothing about the data.
We could ask the user for their age and pass that age as the first argument of the function.
The function would still work and to produce something that doesn't really make sense.
But because the function and the data are not tied together in any way, the function doesn't know that.
It just does what it is asked to do.

If we input 10 and 3, it would result 30.

def calculate_area(width, height):
  return width * height

width = int(input('what is the width? '))
height = int(input('what is the height? '))
area = calculate_area(width, height)
print('the area is', area)

age = int(input('hey, and what is your age? '))
strange_operation = calculate_area(age, height)
print('your age multiplied by the height is', strange_operation)

But now take a look at this code, which is similar.
But after we calculate the area, we also ask for the age and we do a strange operation.
We calculate the area by providing the age and the height.
So you can see that the function works fine, even though we passed an argument that doesn't make much sense.
Now let's take a look at the object oriented approach.

class Rectangle:
    def __init__(self, width, height):
      self.width = width
      self.height = height # class definition (template for creating rectangles)

    def get_area(self):
        return self.width * self.height

a = int(input('what is the width? ')) # So here we ask the user to provide a width and height here down below.
b = int(input('what is the height? '))

rectangle = Rectangle(a, b) # we create a new rectangle object with the width and the height that we got from the user.
print('the area is', rectangle.get_area())

Just try to get the general concept for now.
So in the object approach, this would look something like this.
All you need to know is that this part of the code is a class.

A class is a template for creating objects of the same type.
Our class is named Rectangle and it allows us to create rectangle objects.
When we create the objects, we provide the height and the width.

Then using the code like here we create a new rectangle object with the width and the height that we
got from the user.
From this moment on, Python keeps in memory an object, a structure, a rectangle with a specific width
and a specific height.
The width and the height are tied together.
They are no longer two separate variables, like in their procedural approach.
Instead, they are kept together.

Of course, you could argue that the procedural approach allows us to keep the width and the height together too.
You could, for example, put them into a tuple, into a list or into a dictionary, and you would achieve
a similar result.
But the difference here with the object is that the object not only has the width and the height, it
also has its own function defined within the class get_area.

This function can be used to return the area of this specific rectangle, not any rectangle, but only
this specific rectangle that we created.
You can no longer try to provide the age of the user as one of the arguments.
In fact, there are no arguments when we call the method here.
The method only works in the context of the specific rectangle, and it only works on this specific
object, this specific rectangle with this specific width and this specific height.

And if we run the program now, we can see that it works in the very same way.
But the structure is a bit better.
At first, you could say that there is not much difference between these two approaches.
So the object approach here and the procedural approach here.
You can only say that the object approach looks more complicated than the procedural approach.
It uses some new fancy keywords that you don't know yet, and it generally seems over complicated.
You still get the area of a rectangle by multiplying the width by the height.
you could see that the actual logic that the actual area calculation is the same.
You multiply two numbers by themselves here and you multiply two numbers by themselves here.
So why bother creating a rectangle object from a rectangle class?

Just as I said, the procedural approach is still in use and it is sometimes the best option, typically
in smaller applications, because it's very simple and quick to write.
But, when you start creating bigger applications, when you start working on the code with
other people and you have hundreds or thousands of functions, it's very easy to get lost. 
With bigger applications, People tend to use functions in the wrong way.
They either use functions that are not meant to be used at all, or they use functions with the wrong kinds of arguments.
The end result is chaos.

Object oriented approach allows you to organize this case with objects.
You clearly define what types of data is used in your application.
It is also clearly defined what you can do about the various kinds of data.
The extra effort that you need to put into designing and creating objects really pays off in bigger applications.

Classes and objects
-----------------
Even though we talk about object oriented programming, objects in Python can't exist without classes.
Classes are templates used to create objects.
For example, you can create a class named user.
Classes can contain two types of entities - variables called attributes and functions called methods.

In our simple example, we'll say that each user is characterized by a username and a city.
Each user is also able to introduce themselves.
So we will create a method named introduce.
This gloss will serve as a template to generate specific uses.
You could then have a specific user with username motorknight New York City.
Then you can create another user named Ruler of Darkness London.

These specific users, created on the basis of the user class, are called objects.
Objects contain the attributes and methods specified in the class, so we know that each user object
has a nickname and a city, and we also know that each user object can invoke the introduce method to introduce itself.
This is true at the moment when we create an object because later on we can change the properties and
methods in the object, but we'll get to that later on.

So that's the main difference between classes and objects. Classes are templates used to create specific objects.
We sometimes use the term instantiate. We instantiate objects from classes.
We can also say that objects are instances of the class.
You can't create objects if there is no class, but you can create a class and then never instantiate an object from it.
In other words, a class is an idea which can be used to create specific inclinations called objects.
Each object has a name, a set of properties and a set of methods.

It's time to create the use of class in code and see the syntax when defining class.
We always start with the class keyword followed by the name of the class and the colon by convention.
Class name starts with capital letters.
Class names typically only use letters with no digits or special characters like I have here.
Each class has its own block of code after the colon.
As with any other block of code, you need to use indentation for that.
Now, as we said before, we want each user object to have a username and a city.
If we want to have that, we need to make use of a special function, a special method inside the user class.

This method is generally called constructor because it is used to construct objects of a given class.
The constructor definition needs to begin in a very specific way.

Take a look def init self.
The constructors name is always __init__.

class User:  
  def __init__(self):

If you use any other name, Python will not treat that method as a constructor and it will not use it
to construct new objects.
Just like with any other function in Python, you need to precede the function name with the keyword def.
After the name you need to provide a pair of brackets and provide the arguments.
Finally, you need to add a colon. You may be wondering what this self parameter is.

All Python constructors must have at least one parameter.
It is absolutely obligatory for a constructor to have it.
You can give it any name that you want, but the convention that you should always follow is self.
This self parameter is always pointing to the object that you are currently creating within the constructor.

We want each object of the user class to have two attributes username and asset.
Remember that attributes are just variables in classes.
So inside the definition of in it we're going to write self dot nickname equals sample nickname and
then below self city equals sample city.

class User:  
  def __init__(self):
    self.nickname = 'sampleNickname'
    self.city = 'sampleCity'

In order to inform Python that each object created from class User we should have two properties nickname
and city, we need to use the self argument inside the constructor and provide the name for the attributes 
after single dots.
In general, we use dots in Python objects to refer to the attributes and methods of that object.
This way we are telling Python. Whenever you create a user, give them two properties - Nickname and City.

For now, you can see that each user created from this class will have the same nickname, samplenickname
and the same city - sampleCity.
This definition only tells us that there will be two properties or fields in each user object - nickname
and a city.

Now we also mention that each user should be able to introduce themselves.
In order to do that, we need to create another function inside the user class.
Remember that a function within a class is called a method.

class User:  
  def __init__(self):
    self.nickname = 'sampleNickname'
    self.city = 'sampleCity'
  def introduce(self):
    print('Hello, I am', self.nickname, 'and I live in', self.city)

This time we are not creating a constructor so we can give the function any name that we want.
In this case introduce.
We again use the self parameter here and again this self parameter refers to the current object.
Thanks to it we can use self.nickname and self.city to access the variables or in other words, the
properties of the current object.
Again, we use dots to access specific attributes of the object.

So it's time to create our first object from this class user.
Down here, after the class definition with no indentation will write sample user.
This will be our variable and we'll write user with a pair of brackets.
We create a variable named sample_user just like we always do with any other kind of variable.

class User:
  def __init__(self):
    self.nickname = 'sampleNickname'
    self.city = 'sampleCity'
  def introduce(self):
    print('Hello, I am', self.nickname, 'and I live in', self.city)
sample_user = User()

After the assignment operator, however, we do something new, we provide the name of the class followed
by a pair of empty brackets.
Whenever we provide a name of an existing class and we put a pair of brackets afterwards, Python knows
that it should create a new object from the class.
And how does it do that? By calling the constructor.
In the constructor, we instructed Python to create two variables inside the object, nickname and City.

Even though the constructor has a parameter called self defined here.
We do not provide a value for that parameter when creating an object of the class.
That first argument of the constructor is filled for us automatically and it will always contain a reference
to the object which is being created.
So even though it looks like the constructor requires a single value for the self parameter, in reality
we don't provide anything when we create the object.

Right now that we have a sample user, one thing that we can do is call it introduce method to see how
that works.
To do that, we use the same dot notation on the sample user variable.
So sample user dot introduce and a pair of brackets.

So in order to call a method and an object, we need to provide the variable in which the object is stored.
Then we need to use a dot and after the dot we need to provide the name of the method followed by a
pair of brackets.

class User:
  def __init__(self):
    self.nickname = 'sampleNickname'
    self.city = 'sampleCity'
  def introduce(self):
    print('Hello, I am', self.nickname, 'and I live in', self.city)
sample_user = User()
sample_user.introduce()

Output: Hello, I am sampleNickname and I live in sampleCity

So, again, even though there is a self parameter here defined in this introduced method, this very
first parameter is always provided by Python for us.
So we don't have to provide it when we call the method here.
And you can see that Python prints an introduction statement for us and it uses the nickname and the
city of the given object.

You can also inspect what is hidden in the properties or the fields of the given object.
That's no matter if you want to access an attribute or a method inside an object, you use the dot notation.
The only difference is that accessing methods requires the use of square brackets like here, just like
with any other function in Python.

print(sample_user.nickname) 
print(sample_user.city)
Output: sampleNicknname  sampleCity

And remember that when you create an object from a class, you use the class name followed by a pair
of brackets and here python will know to call this specific method named double underscore init - which
is the constructor.

In particular, all the users have the same nickname, sample nickname and the same city.
We would like to provide our own values in the constructor when we create user objects.

So we'll create a new version of this class here and will do the following.
So we'll add two parameters here usernickname and UserCity.

class User:
  def __init__(self, user_nickname, user_city):
    self.nickname = user_nickname
    self.city = user_city
  def introduce(self):
    print('Hello, I am', self.nickname, 'and I live in', self.city)
sample_user = User()
sample_user.introduce()

And now, instead of the default values, will do the following.
As you can see, we simply add two new parameters to the constructor and we can then use these parameters
inside the constructor to create the properties of the object.
The parameter names can have well any name that you want, just like with any other function in Python.
One interesting thing is that the parameter names can be even identical with the fields in the object.
You can use nickname and you can use set a and then set it like this.

This may look a bit weird because it looks like the same variables really, but they're actually different.
The self.nickname variable refers to the property of the object and the nickname variable without
the self prefix is the argument passed to the constructor.

class User:
  def __init__(self, nickname, city):
    self.nickname = nickname
    self.city = city
  def introduce(self):
    print('Hello, I am', self.nickname, 'and I live in', self.city)
sample_user = User('DarkKnight', 'Heaven')
sample_user.introduce()
print(sample_user.nickname)
print(sample_user.city)

Now you can see that our user has the exact nickname and city that we provide it in the bracket when
we created the user.
Again, note that the constructor has three parameters self, nickname and city, but we only provide
two parameters when we create the object.
That's because the first argument is the reference to the object being created and Python provides that
automatically for us.
Once we create a class, we can instantiate many different objects from it.
Let's create two more users here.

first_user = User('Martin', 'Luther')
second_user = User('Winston', 'Churchil')
third_user = User('Willie', 'King')

So now we have three new users first user, second user, and third user.
And now we can do first user introduce than second user introduce and third user introduce.

first_user.introduce()
second_user.introduce()
third_user.introduce()

And you can see that all three objects have a methods named introduce because all of them were created
based on the class.
---------------------------------------------
All right, let's create a new simple class now.
The class will be called car.
It will be a very simple class that describes a very generic column.
It will have three properties modal color and current speed.
So we'll start by creating a constructor for this class.
As we said before, the constructor must always have a special name. Double underscore in it.

class Car()Ș
  def __init__(self, model, colour, initial_speed)
    self.model = model
    self.colour = colour
    self.speed = initial_speed

The first argument is by convention name to self and to references the object that is being created.
The next three arguments are the model color and the initial speech of the car.
These three arguments will be provided by the user of the class when they create new car objects.
So let's run the cell and now we'll create new car objects.

My lovely car equals car, t rock and then red.

And the initial speed of let's say five.

And when you run the code, you can see that everything works fine.

Now do you remember how to provide default values for function parameters?

Turns out that it works with constructor and other methods within classes too.

So all we need to do is the following.

And now every car that is created without providing an initial speed will be given the default value

of zero.

So now it's possible to create a new car using one argument less and Python will fill that automatically

for us.

Let's try it out so we'll delete the initial speed and everything works like a charm.

Perfect.

Our class is defined, but it doesn't do anything useful yet.

We'll add two new methods to the class that will make the class speed up or slow down.

So we'll do the following.

Def speed up self self speed plus equals five and the similar method def slow down self self speech

minus equals five.

All right, we're on the cell.

And remember that each method in your class should contain a single parameter at least, which is by

convention named self.

This argument allows you to access the object's properties and increase or decrease the speed by five

respectively.

All right, we'll add one more method that will present the current speed to the user.

So we'll do def show speed self and it will do print current speed and after a comma cell speed round

the cell.

Right.

And now let's run some tests.

So using the my lovely car object, we're going to do the following.

My lovely car speed up, then my lovely car speed up again.

And after these two operations, we want to show the speed to the output.

Run the cell and you can see, oh, there is a typo here and you can see that the current speed is ten.

After increasing the speed twice perfect.

We can see the speed of ten.

But now this one problem.

If the current speed is zero, it shouldn't be possible to slow down.

But let's see that in practice.

So instead of speed up we'll do slowed down after creating the object and will do that actually twice.

And you can see that the current speed is minus ten.

A speed of minus ten.

Doesn't really make much sense.

We should modify our code so that it doesn't decrease the speed below zero.

Fortunately, that's pretty simple.

So in the slow down method, we're going to do the following if cell speed is slower than five.

Self speed equals zero.

Otherwise decrease this speed.

By five.

All right.

If we now run the program, we can see that the speed never goes below zero.

Perfect.

But there's one more problem.

What happens if the user provides a value below zero when they create a call?

Take a look now.

So instead of the two argument version and the default value of zero for this speech, we're going to

do the following -50.

And now if we try to show the speed without slowing down or speeding up, you can see the value of -50.

Well, that doesn't make much sense either.

We need to also modify our constructor so that it doesn't allow speech values below zero.

One way of dealing with that could be as follows.

So here.

After setting model or color, we can check if initial speed below zero then self speed should be equal

to zero.

Else it should be equal to the argument passed around this cell and now run this one.

And you can see that even though we provided a value of -50, the current speed is actually zero.

So the constructor modification worked fine.

If the user creates the car with a speech value below zero, we will simply put zero as the initial

value.

Our class is now almost bulletproof in terms of speed, but unfortunately, there's one more way that

the user may try to hack our class.

Take a look.

So here, after creating, the object, will do my lovely car speed.

Equals minus ten.

As you can see, the user can simply access the speech property directly using the dot notation and

set any speech value that they want.

Oopsie.

What can we do about it?

The user does not call any method defined in the clause, so there is no place where we could add some

checks for speeds below zero.

Luckily, there is a way to kind of stop the user from changing the speech property directly.

We need to make the property private.

A private property is a property that can only be accessed from within the class.

In one of the methods, but never outside the class after the object is created.

So in the properties private, you can't do an operation like this.

Different programming languages implement the concept of private properties differentially in Python.

If you want a private property, you need to give it a name that starts with two underscore signs.

So we'll need to do a lot of refactoring now in the class itself.

So take a look here instead of speed will do to underscore speed.

Same here, here and in all the places.

Right.

Let's run the class and now let's run this cell.

And you can see the current speed of zero.

Now, with the double underscore in front of the property, the code works fine.

We couldn't change the value of the speech property, as you could see, and the speed was still zero

after this line.

In reality, there's a bit more happening behind the scenes, but we'll get back to that later.

Incidentally, there are four main principles behind object oriented programming in most modern programming

languages encapsulation, abstraction, inheritance and polymorphism.

These names may sound scary to you, but don't worry, we'll explain them over time in this video.

The usage of private properties mainly addresses the concept of encapsulation, and encapsulation says

that objects should keep their state private and only expose a set of public functions to the outside

world.

This is exactly what we did here.

We made the speech property private, so we heard the state of the object from the outside world and

we exposed two methods speed up and slow down to manipulate the property in a way we previously defined.

This also shows the second principle behind object oriented programming.

Abstraction.

Abstraction says that objects should keep the details of how they work to themselves and only expose

some high level operations to the outside world.

A good analogy could be a smartphone.

Your smartphone comprises a lot of electronic parts, on top of which there are millions of lines of

code so that it can work properly.

But you do need to know that the details of how your phone works are hidden from you.

You only get access to some high level operations, like making a phone call or sending a text message.

You are not aware of how your phone does all of this.

In other words, the details are abstracted from you.

The same thing goes for our car closely.

Theoretically speaking, if someone uses your car clause, they don't even need to know that there is

a speech property in sight.

They can create a car object without providing any speed, and then they can only use the speech up

and slow down methods.

The details of what happens inside the object when you call these methods are abstracted away from you.
