MODULES
decomposition = breaking code into smaller pieces
- besides separating into more files, we need to inform python that separate files should cooperate and form a bigger codebase
- a module is simply a file that contains python definitions and statements
Such a file can be imported into a second file, and once you import the module, you can use all the
definitions and statements from that module in that second file.
- You can create your own modules and you can also use modules created by other Python enthusiasts like you, 
- most importantly, you can use a lot of modules that are delivered together with Python.
- These modules form the so called Python Standards Library and you can go to Python documentation online
to see what the library contains.
I've got the link here. docs.python.org/3/library/index.html#the-python-standard-library

Let's take an example of a module called sys.
As you can see, it has system specific parameters and functions.
If you enter the module description page, you can find all the module entities like AB flags, adduaditbhook etc.
The entities are all the definitions, like variables and methods that you can use when you decide to use this module in your code.

Among other things, there is sys.exit. in practice, this function closes your program by raising an exception.

IMPORT MODULE
import sys, math
for name in dir(sys):
    print(name, end='\t')
# The dir() function returns all properties and methods of the specified object, without the values.
# in our case, this function allows us to see all the entities that this module makes available

import sys
sys.exit() # exception occurs of type SystemExit
# we use the name of the module before calling the function in order to not be mistaken by another function with the same name

# if we want to specify the exact entities from the module we are interested in
# we no longer need to specify the module before the function using this syntax
from sys import exit
exit()

from sys import exit
def exit():
    print('i wanna exit')
exit() # this function will be called instead of the imported one as it is overwritten by the one we defined with same name

1. import sys
2. from sys import * 
# this is not recommended as many functions will be replaced and conflicts will appear
# both statements input all the entities from CIS module
# using first option you need to remember about sys prefix/namespace, to add sys.x
# using the 2nd option we do not need to specify the namespace but we can get a lot of conflicts

# we can use aliases when importing
import sys as s
s.exit()

from sys import exit as bye
bye()

MATH MODULE
The moth module is among the most frequently used ones in Python.
It contains a lot of mathematical symbols and functions that you may want to use in your Python programs.
First, we'll import math.

import math

For the PCP examination, though, you need to know just six functions from these.
We can start with three similar functions used to round numbers.
These are ceil(), floor() and trunk().
What's the difference between them?

Let's analyze a simple example.
So we'll do print math.ceil(3.6), math.floor(3.6), math.trunc(3.6)
And when we run the program, it will output 4 3 3.
What's the difference between the three when it comes to ceil? it always rounds the number upwards
to the nearest integer, never less than the number itself. (3.1 -> 4 ; -5.6 -> -5)

Floor function does the opposite. It rounds the number downwards to the nearest integer. (3.1 -> 3 ; -5.6 -> -6)
Returns three because three is not less than 3.0.

trunk() is the easiest function of the three.
This function is simply removes the decimal part and returns the integer from the number.
And you can see that in each case we simply get the number before the decimal part. (3.1 -> 3 ; -5.6 -> -5)

You can use the round function, but it's not required for the examination.
You also need to know the factorial function.
What is a factorial in maths?
It is the multiplication of all positive integers less than or equal to the given number.
The factorial for three is three times two times one, which is six.

print(math.factorial(6)) # output 120

The next function that you need to know is sqrt(), which stands for the square root.
As the name suggests, the function simply returns the square root of a given number.
So, for example, print math asked of 16 would give us 4.0 because four times four is 16.
Note that even though we provide an integer, we get a float in the result.

print(math.sqrt(16)) # output 4.0

Finally, you need to know the hypot() function.
This one has to do with geometry and triangles to be precise.
If you have a right angle triangle and you know the length of the two shortest sites, you can use the
hypot() function to find the longest side, which is also called the hypotenuse.
print(math.hypot(3, 4)) # output 5.0

RANDOM FUNCTION
Another frequently used module in Python is called random. It provides random values.
Computers can't use imagination to think of a random number.
They can only follow an algorithm with some clear predefined steps, and it's difficult to come up with
something random when the steps you take are always predefined.
The algorithms will typically start with a seed. The seed can be treated as a starting value from which Python 
does some fancy computations to output pseudo random numbers.
If you use the same seed, you will typically always get the same pseudo random numbers.
Python can output more than one number based on the same seed.

For example, you could start with a seed of one and then get a pseudo random number of five when you
first ask for a random number.
The second time you ask for a random number, you could get, let's say, three.
The third time it could be something like 11 and so on.
The numbers may seem perfectly random, but if you close your program and start it again, you will get the same numbers.
Not really random anymore, right?
That's why ideally the seed should also change over time.
This way you will get different random numbers if you run your program again later on.
And how do you ensure that the seed changes over time?
The easiest way is to use time.

Python can take the current time and change it into a number that will become the seed for pseudo random
number generation.
And because the current time is always different, the seed will also be different.
As a result, you will get different random numbers.

The most general function in this module is also called random.
It produces a float number between zero and one.
Let's call this function three times in a row and see what we get.

import random
print(random.random())
print(random.random())
print(random.random())
output: 0.27 0.73 0.30

You can see that we got three different numbers.
If we rerun the cells, you can see that the numbers change. 0.47 0.65 0.98
That's because by default, Python changes the seat for you, usually based on the local time stamp on your machine.
If for any reason you want to set the seed yourself, you can use the seat function.

import random
print(random.seed(0)) # set the seat to zero.
print(random.random())
print(random.random())
print(random.random())
output: 0.84 0.75 0.42

Now, you can see that the pseudo random values don't change.
They are all based on the same seed of zero.
So the series of numbers will receive is always the same.

Two more functions that you need to know for the Pcap exam are choice() and sample().
They are a bit similar because both of them take a sequence as an input.
A sequence could be a list, a string, and the output randomly selected items from the sequence.

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
names = ['Alan','Kate','Mary','Kate','Jo','John']
print(random.choice(numbers))
print(random.choice(names))

And now we have, as you can see, two sample lists, one with integers and one with strings.
The choice function works with both of them.
It accepts a sequence as the input and outputs a random element from this sequence.
Naturally, we can use sequences other than lists.
These could be strings or something else.
So for example, you can pick a random character from a string using random.choice().

And now I have something like this prepared to get a long string.
Can you feel the power of Python and you get a random letter and each time you run the cell you get
something different.

random.choice('CanYoufeelThePowerOfPython')

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for i in range(10):
    print(random.choice(numbers))
output: 10 4 9 3 5 3 2 10

You can see that the choice function doesn't care about duplicates.
It returns one random element at a time.
But that element can be any element, also an element that was already returned in one of the previous invocations.

Imagine that you have a list of participants in a contest and you want to generate a random order for
their appearance on stage.
In this case, you can't get the same person twice.
You need to ensure that the order is random, but that each participant is only shown once.

That's why you can use the sample() function.
This function takes to arguments, a sequence and the number of elements that should be randomly taken
from the sequence without duplicates.

names = ['Alan','Kate','Mary','Kate','Jo','John']
random.sample(names, 3)

This code picks three random names from the list and returns them as a new list.
Note that the names will always be unique (when referring to the index, not the value).
Naturally, the second argument might not be greater than the number of elements in the sequence.

PLATFORM MODULE
- it has access to underlying platform identifying data and can give you data about python version, OS, HW 
(it shows the layers between your code and the hw your computer is using)

The documentation describes it as access to underlying platforms identifying data.

In other words, the platform module can tell you a little bit about your Python version, the operating
system, and the hardware you're using.
Take a look at the diagram. It shows the layers between your code and the hardware that your computer is using.
Your code is located at the very top one level below.
There's the running environment of Python.
The next layer is the operating system or OS for short.
Python uses a lot of helpers from the operating system for things such as processing files or communicating
with physical devices.
At the very bottom, there's the hardware, the processor, the RAM, memory network interfaces, user
keyboard and mice and others.
All of the four layers cooperate so we can write Python programs.
For example, when you want to get some user data, your code can invoke the input function.
The Python environment accepts the order and adapted to meet the requirements of the local operating system.
These can be different for Windows, Linux or Macintosh, but you do need to worry about it.
The OS checks if the request from Python is valid and it uses the hardware in this case the keyboard
to complete your request.
The platform module allows us to access some basic information about the underlying layers the Python
environment, the operating system and the hardware.

Let's look at the functions that you need to know for the examination.
First of all, we'll import the module and now we'll start with platform.

This function returns a string that identifies the underlying platform.

The input is intended to be human readable.

As you can see here, the platform that I'm using is Windows ten with this specific version.

The function actually takes two parameters that have some default values.

That's why I didn't have to provide any arguments when alias is set to true or any non-zero value.

The function may present alternative underlying names.

This parameter will not do anything on certain platforms while on others it can show system names that

differ from common names when test is set to true in turn or any non-zero value.

The function will try to present a briefer form if any such form is available.

So for instance, if I set both of these to true, you can see a brief form Windows ten.

All right.

The next function is called machine.

Platform.

Machine.

It returns the generic name of the processor which runs your OS.

A similar function is called processor.

It returns the real name of the processor.

For some processors, it will print the exact same information as machine.

But as you can see in my case, the info is different.

Next there is a function named system.

And this function returns the generic operating system name.

In my case it is Windows.

And then there are two more functions that you need to know.

These functions relate to the Python implementation itself.

Python implementation returns the name of your Python implementation.

The default value here that you should expect is C Python.

C Python is the default and most widely used implementation of the Python language written in the C

language.

If you installed Anaconda the way I requested, I would be very much surprised if you had anything different

than c python here in the output.

Finally Python version tuple.

Unlike all other functions presented in this video, this function does not return a string.

Instead it returns a topple with three elements.

The first element is the major part of the Python version.

The second one is the minor part, and the last one is the patch.

So in this case, my python version is 3.9.7.

And that's it.
