list comprehensions
-------------------
numbers = []
for i in range(1, 101):
  numbers.append(i)
print('Numbers', numbers)
output: Numbers: [1, 2, ... 100]

numbers = [i for i in range(1, 101)] 
print('Numbers', numbers)
output: Numbers: [1, 2, ... 100]

numbers = [i for i in range(1, 101) if i % 3 != 0] 
print('Numbers', numbers)
output: Numbers: [1, 2, 4, 5..., 98, 100]

numbers = [0 if i % 2 == 0 else 1 for i in range(100)] 
print('Numbers', numbers)
output: Numbers: [0, 1, 0, 1, ... 0, 1]

table = [i for i in range(1, 6)]
print(table)
output: [1,2,3,4,5]

table = [[i for i in range(1, 6)] for j in range(5)]
print(table)
output: [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5]

============
lambda functions
---------------
Lambda functions and Python are used to simplify code to make it easier to understand shorter and clearer.
A typical function in python is defined like this.

def function_name(parameter1, parameter2):
# instruction1
# instruction2

A lambda function in Python in turn looks something like this.

lambda parameter1, parameter2: # instruction

The two major differences that stick out almost immediately are that a function always has a name.
A lambda in turn can be used without giving it any name.
The second difference is that a lambda can only contain a single instruction.
Let's write the very same function in two ways using the classic approach with the keyword def and using
a lambda.

This will be a very simple function that accepts just two numbers and adds them together.
pens in the output.

def sum(a, b):
  return a + b

lambda a, b: a + b
output: <function__main__.<lambda>(a, b)>

First of all, the Lambda version is much shorter.
Second of all, the Lambda version does not need to return keyword and of course the variables can be
named differentially.

Now, the problem with the code we have right now is that the sum function can be easily called.
We just need to write something like for instance, some five and three and that's it.

sum(3, 5)
o: 8

But how do we call the lambda if it doesn't have a name?
we can save the lambda function into a variable and to use the variable name to call the lambda.

another_sum = lambda a, b: a + b

And now you can see that both of these functions, the classic one and the Lambda one, are invoked
in the exact same way.

You may be wondering if Lambda functions can be used in the same way as normal functions.
Why do they exist?
There are a few situations where lambdas come in handy.
One of the superpowers is that they can be passed around just like variables.

def apply_func(elements, func):
  for element in elements:
    print(func(element))

Suppose that we have a list of numbers from 1 to 5 and we want to print their values to the second power.
We can do it in the following way:
And now as the second parameter we are going to add my func Look what happens here.
The first argument contains the elements to iterate inside.
Apply func numbers from 1 to 5.

my_func = lambda x: x * x
apply_func([1, 2, 3, 4, 5], my_func)
output: 1 4 9 16 25

Now for each of the elements, we want to apply the function pass as the second parameter.
The function is a lambda that we saved in the my func variable.
It takes one argument and returns the argument squared.
Now in the output we can actually see that for each element, the apply func function used the lambda
to calculate the second power and then it's printed the result.
The beautiful thing about the apply_func function is that it can work with so many different lambda
types. 

For instance, if you want to do something else with each number, let's say you want to find the reverse
number for each of them.
You just need to change the lambda.

my_func = lambda x: 1 / x
apply_func([1, 2, 3, 4, 5], my_func)
output: 1 0.5 0.33 0.25 0.2

The lambda is defined directly in the function invocation here.
You do need to create a special variable for it.
Note that the lambda is not saved anywhere in this setup.

apply_func([1, 2, 3, 4, 5]), lambda x: x * x)
out: 1 4 9 16 25

Once this line is executed, the lambda is lost and you can't reuse it later in the code.
But this is exactly what we needed.
A simple way to define a function in line with the function invocation itself.
They allow you to write shorter, clearer code without defining unnecessary variables.
Lambda functions are sometimes called functions without names or anonymous functions.
When you take a look at the last example, you can easily understand why, as the lambda here does not
have any name and is quite anonymous.

========================
map and filter with lambda functions
------------------------------
two functions that accept lambdas.
First, let's talk about map.
Map typically takes to arguments.
The first one is a function.
The second one is a sequence with some elements.
Then map applies the function to all the elements in the sequence.

We wrote a very similar function in the introductory video about lambdas, but map is a bit more universal.
Instead of printing to the output the result of each invocation, it creates a structure called an iterator.
an iterator is an object that allows you to retrieve the elements one by one in a loop or convert them into a list.

Let's see that in practice, we'll create a lambda function that will multiply a given number by two
and we'll also have an initial list.

lambda_func = lambda i: i  * 2
initial_list = [1, 2, 3, 4, 5]

map(lambda_func, initial_list)
<map at 0x324235345>

The first argument is the lambda.
The second argument is the sequence with elements like this.
Now, if we run the code, you can see that we don't get to see anything meaningful.

As I said, map returns an iterator, a special kind of object.
When you print the iterator, you can simply see its identify in the memory, like with many other types
of objects.

Let's save the resulting iterator into a variable and use the next function to get a single value from
the iterator.

map_result = map(lambda_func, initial_list)
print(map_result)
o: 2

And let's use the print invocation around it and let's see what we get.
You can see the value to returned.
This is the first element in the iterator.
After applying the lambda function, you can use subsequent next goals to get subsequent results.
We are going to repeat that for the second, third, fourth, fifth and sixth time.

map_result = map(lambda_func, initial_list)
print(map_result)
print(map_result)
print(map_result)
print(map_result)
print(map_result)
print(map_result)

o: 2 4 6 8 10 
stopiteration err

And you can see all the values printed to the output and at the very end and exception raised stop iteration.
This means that there are no more values to return.
But as you can see, this way of working with iterator is not really convenient.
Instead, we could use a for loop, so we are going to do the following in the new cell.

I'm going to do four element in map result.

Print the element and finish it with a comma like this.

map_result = map(lambda_func, initial_list)
for element in map_result:
  print(element, end=',')
o: 2, 4, 6, 8, 10, 

Another way is to use the list function to simply get all the output from the iterator into a nice little
list.

map_result = map(lambda_func, initial_list)
print(list(map_result))
o: [2, 4, 6, 8, 10]

So if we gather all the codes together, that's create the lambda and the list and we add this.

lambda_func = lambda i: i  * 2
initial_list = [1, 2, 3, 4, 5]
map_result = map(lambda_func, initial_list)
print(list(map_result))
o: [2, 4, 6, 8, 10]

Believe it or not, we can reduce all of this code into a single line like this.

print(list(map(lambda i: i * 2, [1, 2, 3, 4, 5])))
o: [2, 4, 6, 8, 10]

So we have the printing location, the list function, the map function, the lambda defined inside
and the list provided directly.
And now if we run this code, it works the exact same way.
See how we convert it? All of the four lines into a single line of code.

That's one of the secrets powers behind Python.
You can really reduce your code to the bare minimum.
Now let's talk about filter.

Filter works in a similar way to map.
It also accepts a function and a sequence.
It's also returns an iterator.
The difference between map and filter is that filter uses the function to well, as the name suggests,
to filter the elements of the sequence.


Take a look at this example.
The lambda will be a bit different so we want to check I divisible by two must be equal to zero and
let's maybe have more elements here to see the result.
And so let's break it to the output.
So we have a list of numbers from 1 to 8.
We would like to have a new list that only contains even numbers to do that we make use of the filter
function here.

The lambda in this case contains the condition that each matching elements should satisfy.
When we divide the elements by 2, we should receive zero.
In other words, this means check if the element is an even number.
If it is, the filter function keeps the element.
If it isn't, the filter function removes the element from the result.
And just as the function name suggests, we successfully filtered out all all two numbers and only got
even numbers in the resulting list.

print(list(filter(lambda i: i % 2 == 0, [1, 2, 3, 4, 5, 6, 7, 8])))
o: [2, 4, 6, 8]

We will provide a list of email addresses and we will filter out those that are fake.
That is, they don't contain the ad sign.
I have a list of some email addresses like here.
There is a column here that we don't need.

emails = [
'frank@gmail.com',
'i love python',
'e74583',
'journal@yahoo.com',
'fsiaddr'
]
list(filter(lambda x: '@' in x, emails))
o: ['journal@yahoo.com', 'frank@gmail.com']

You can see that we got a list of email addresses and some of them were not real addresses.
We use the filter function to get rid of these values in the list that did not contain the app sign.
As you can see, thanks to Lambda, we only needed a single line to get a new list with correct email
addresses.

========================
closures
------------------------------
If you take a look at the formal definition of a closure, you will find something like this.
A closure is a technique for implementing lexical scoped name binding in the language with first class
functions.
A more digestible definition would be something like this a closure as a function defined inside another
function that remembers the values of the outer function.

def greet(text):
  def print_greet():
    print(text)
  return print_greet
say_hello = greet('hello')
say_hellow()
o: hello

We define a function named grid.
This function takes a single argument, a text value.
Next, inside the greet function, we define another function print_greet
Print_greet is called a nested function.
As you can see, you can test functions in Python the same way that you can nest for loops or if statements.
This nested function doesn't take any arguments inside.
It prints the text variable to the output.

As you can see, the nested function has access to the variables available in the outer function.
So even though print_greet doesn't get text as an argument, it can access the variable because the variable
is available in the outer function.
That nested function print_greet becomes a closure the moment it references a variable from the outer
function.
If we didn't reference any variables from the greet function, print_greet would simply be called a nested
function.
But when we access that text variable inside print_greet, it immediately becomes a closure.

And now the second interesting thing happens we return the closure from the outer function.
Note that we don't add brackets to the closure name.
That's because we don't want to invoke the function.
We simply want to return it.
In Python, whenever you add a pair of round brackets, be it with or without arguments inside, you
instruction python to call the function.

Without the brackets here we simply return the nested function without calling it.
because we return a value from the outer function.
That value can be saved into a variable.
That's what we do on the next line.
We call the greet function with a single argument.
And we store the result in the say hello variable.

Note that at this point nothing has been printed yet.
The print invocation is contained inside the print_greet closure.
But the closure was never called, so there's nothing printed to the output yet.
Now look what happens on the last line.
We add a pair of round brackets to the variable name.

This means try to invoke whatever is contained inside the say_hello variable and because say_hello contains
a closure, that closure is invoked.
The closure contains a print statement so we can see something printed to the output.

The closure remembers the value of text.
The closure knows that it should print hello to the output, even though we don't pass anything when
we call the closure on the last line.
That's a very important feature of closures.

They can store values from the outer functions, even though these functions have finished executing
and the values should be, theoretically speaking, already destroyed.
Such variables, variables that should be already destroyed but are still available in a closure are
called free variables.

Closures are not very intuitive at first sight.
So let's analyze another example.

We create a function named make_multiply_closure.

def make_multiply_closure(x):
  def multiply(y):
    return x * y
  return multiply
multiply_5 = make_multiply_closure(5)
multiply_12 = make_multiply_closure(12)
print(multiply_5(10))
print(multiply_5(20))
print(multiply_12(10))
print(multiply_12(20))


It accepts a single argument named X.

Then inside the function we create a closure named multiply that accepts an argument of its own.

Why the closure is returned from the function.

Now we create two variables multiply five and multiple 12.

The first one invokes the outer function with an argument five.

The second one invokes the outer function with an argument of 12.

These variables now contain the same closure with two different values for X five and 12.

Later in the code, we can call each closure version and provide an argument which will be used as the

second number, the Y parameter in the inner function.

Here, the closure remembers the first number and multiplies it by the second number provided.

Now, as you can see, closures can be a bit difficult to understand.

It's easy to lose track of what argument is stored, where to make it easier.

Remember how the outer function and the inner function are invoked in the first example, the outer

function greet required a single argument and when we created the closure, we had to provide it here.

Hello.

Then when we call to the closure, you could see that we did not provide any arguments.

That's because when you look at the inner function definition here, there is no parameter defined.

Now let's analyze the second example here.

The outer function requires a single argument passed.

So when creating the closure here and here, we provided a single argument twice.

Then when invoking the closure, you could see that we provided a single argument each time here.

That's because the inner function required a single value y to be passed each time.

So as you can see, closures become a bit easier to understand when you check carefully the arguments

that they require.

Now you may be wondering what a closure is good for.

Are they actually used in Python?

What for?

The answer depends on personal preferences.

Some people make heavy use of them, some don't.

Closures can sometimes replace small classes.

If you have a class that only has one custom method, you can typically replace it with a closure and

the code will be shorter to read.

Some Python libraries and design patterns also use closures, so it's good to be able to identify them

when you read someone else's code.
