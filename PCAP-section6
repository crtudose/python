list comprehensions
-------------------
numbers = []
for i in range(1, 101):
  numbers.append(i)
print('Numbers', numbers)
output: Numbers: [1, 2, ... 100]

numbers = [i for i in range(1, 101)] 
print('Numbers', numbers)
output: Numbers: [1, 2, ... 100]

numbers = [i for i in range(1, 101) if i % 3 != 0] 
print('Numbers', numbers)
output: Numbers: [1, 2, 4, 5..., 98, 100]

numbers = [0 if i % 2 == 0 else 1 for i in range(100)] 
print('Numbers', numbers)
output: Numbers: [0, 1, 0, 1, ... 0, 1]

table = [i for i in range(1, 6)]
print(table)
output: [1,2,3,4,5]

table = [[i for i in range(1, 6)] for j in range(5)]
print(table)
output: [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5]

============
lambda functions
---------------
Lambda functions and Python are used to simplify code to make it easier to understand shorter and clearer.
A typical function in python is defined like this.

def function_name(parameter1, parameter2):
# instruction1
# instruction2

A lambda function in Python in turn looks something like this.

lambda parameter1, parameter2: # instruction

The two major differences that stick out almost immediately are that a function always has a name.
A lambda in turn can be used without giving it any name.
The second difference is that a lambda can only contain a single instruction.
Let's write the very same function in two ways using the classic approach with the keyword def and using
a lambda.

This will be a very simple function that accepts just two numbers and adds them together.
pens in the output.

def sum(a, b):
  return a + b

lambda a, b: a + b
output: <function__main__.<lambda>(a, b)>

First of all, the Lambda version is much shorter.
Second of all, the Lambda version does not need to return keyword and of course the variables can be
named differentially.

Now, the problem with the code we have right now is that the sum function can be easily called.
We just need to write something like for instance, some five and three and that's it.

sum(3, 5)
o: 8

But how do we call the lambda if it doesn't have a name?
we can save the lambda function into a variable and to use the variable name to call the lambda.

another_sum = lambda a, b: a + b

And now you can see that both of these functions, the classic one and the Lambda one, are invoked
in the exact same way.

You may be wondering if Lambda functions can be used in the same way as normal functions.
Why do they exist?
There are a few situations where lambdas come in handy.
One of the superpowers is that they can be passed around just like variables.

def apply_func(elements, func):
  for element in elements:
    print(func(element))

Suppose that we have a list of numbers from 1 to 5 and we want to print their values to the second power.
We can do it in the following way:
And now as the second parameter we are going to add my func Look what happens here.
The first argument contains the elements to iterate inside.
Apply func numbers from 1 to 5.

my_func = lambda x: x * x
apply_func([1, 2, 3, 4, 5], my_func)
output: 1 4 9 16 25

Now for each of the elements, we want to apply the function pass as the second parameter.
The function is a lambda that we saved in the my func variable.
It takes one argument and returns the argument squared.
Now in the output we can actually see that for each element, the apply func function used the lambda
to calculate the second power and then it's printed the result.
The beautiful thing about the apply_func function is that it can work with so many different lambda
types. 

For instance, if you want to do something else with each number, let's say you want to find the reverse
number for each of them.
You just need to change the lambda.

my_func = lambda x: 1 / x
apply_func([1, 2, 3, 4, 5], my_func)
output: 1 0.5 0.33 0.25 0.2

The lambda is defined directly in the function invocation here.
You do need to create a special variable for it.
Note that the lambda is not saved anywhere in this setup.

apply_func([1, 2, 3, 4, 5]), lambda x: x * x)
out: 1 4 9 16 25

Once this line is executed, the lambda is lost and you can't reuse it later in the code.
But this is exactly what we needed.
A simple way to define a function in line with the function invocation itself.
They allow you to write shorter, clearer code without defining unnecessary variables.
Lambda functions are sometimes called functions without names or anonymous functions.
When you take a look at the last example, you can easily understand why, as the lambda here does not
have any name and is quite anonymous.
