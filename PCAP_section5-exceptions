Exceptions - syntax errors
-----------------------
you can use the default except block to catch any sort of exception:

try:
  # your code
except:
  # any exception
However, there is one special exception type: SyntaxError. You should pay attention to how it works.

If you raise a SyntaxError manually, then you can catch it in the except block just fine:

try:
  raise SyntaxError
except:
  print('Got it!') # SyntaxError is caught here

However, if you make a syntax error in the try block and Python automatically raises a SyntaxError for you, then you cannot catch it:

try:
  5:4 # this line generates a SyntaxError
except:
  print('Got it!') # SyntaxError is NOT caught here

================
try/except with else
------------------
try: 
    value = int(input('enter an int: '))
    print(1/value)
except:
    print('something went wrong')
else:
    print('everything is perfect')

if we provide 0 - first branch will be printed
if we provide any other value - second branch will be executed

==========
finally
----------
Finally, Python offers an additional keyword that can be used with try accept blocks.
Finally, it must be the very last branch of the code intended for handling exceptions.
It must appear even after the ls block ls and finally are not dependent on each other.
You can have both of them.

You try block only one of the two or none at all.
The general rule is that the final block is executed always, no matter if an exception is raised or
not, no matter if a raised exception is handled or not.
Then finally, BLOCK will always execute in real life programming.
Finally, blocks are typically used when we work with some external resources, such as databases or
text files.

For instance, when we want to retrieve some data from a database, we first need to open a connection
to the database, then retrieve the data and then close the connection.
It's then a good idea to close the connection in a final block, no matter if our code succeeds or not.
No matter if we manage to retrieve the data or we get a connection error, we should always close the
connection to the database to limit the amount of memory that the machine uses.

So I'm going to give you a simple example of finally using a division error.
We are going to define a function named get inverse.
And we are trying to return the inverse of X.

def get_inverse(x):
  try:
    return 1 / x
  except ZeroDivisionError:
    return None
  finally:
    print('i am always printed')

print(get_inverse(5))

output1: i am always printed
0.2

print(get_inverse(0))
output1: i am always printed
None

Now we know that this may produce some errors, so we are going to accept zero to vision error.
In which case we return none.
And we are going to add a final block here and we will print.
Run the cell and now in the new cell we are going to do print, get in verse five, which is all good.
And you can see 'I am always printed' to the output and now with an exception, if we provide the number
zero, you can also see 'I am always printed'.

So note that in both situations the final block is executed before the function finishes and returns
the actual number.
In the second case we get a zero division error and we return none.
But before that happens, in both cases we see I am always printed to the output because of the final
block.

==========
raise exception
----------
So far we've only seen examples where Python raises exceptions for us when we try to divide by zero.
Python automatically erased an exception when we tried to access a non-existing array index.
Python raised an exception. All of that happened automatically for us.

Python allows you to raise exceptions on your own.
Raising exceptions on your own is typically used in two types of situations.
When you write tests to check your programs, you can raise exceptions to verify how your piece of code
will behave.
If, during the execution of your program, Python suddenly raises a real exception.

The second use case is when you want to make another part of the program responsible for handling the
exception.
This can be very useful in larger applications.
To raise an exception, we use the keyword to raise, followed by the name of the exception.

For example, let's say that we want to define a function that returns the bigger number of two.
we want to check if a or b is not an instance.

def returb_bigger(a, b)
  if not isinstance(a, int) or not isinstance(b, int)
    raise ValueError
  if b > a:
    return b
  else:
    return a

print(return_bigger(5, 3))
out: 5
print(return_bigger(5, 'b'))
out: valueerror

So here in the return bigger function, we assume that both arguments will be of type integer.
We checked out at the very beginning of the function.
If at least one of the numbers is not an integer, we manually raise a value error here by using the
raise keyword.
You can see how that works when we try to invoke the function with an invalid argument.
There's also another usage of the word riase.
You can use it without any exception name inside the except branch.
This instruction will then raise the very same exception as currently handled.

def return_reverse(x)
  try:
    return 1/x
  except:
    print('something went wrong')
    
return_reverse(0)
out: something went wrong

So this is a version without the keyword raise.
And if we do return reverse of zero.
When we run the coach, you can see that for argument zero.
We simply see something went wrong printed.
What happens when we add the raise keywords?

So let's copy paste that into a new cell like this.
And here we are just going to add to raise run the cell again.
And now if you try the very same invocation.
This time you can see something went wrong in the output, but we can also see that the zero division
error was raised again.

def return_reverse(x)
  try:
    return 1/x
  except:
    print('something went wrong')
    raise

return_reverse(0)
out: zerodivisionerror

This programming technique is sometimes used when you only want to handle an exception partially, and
then you want to raise the exception again.
So that's another part of the code finishes the exception handling.

===============
exceptions as objects
----------------
talk about the objective nature of exceptions.
Yes, exceptions in Python are objects.
Whenever an exception is raised in Python, an object of the given exception class is created and it
goes through all the branches of the try except block to find a matching branch.
The exception object has some information that you can use to precisely identify what went wrong.
In order to get that information, you need to extend your accept block using a special keyword as take
a look.

We are going to write a function named Return Bigger that you already know from one of the previous
videos.
If B is larger than a return B, else return A except exception.
As E and now print E and return none.
And now if we try print, return figure of five and let's say be, you can see a new kind of message.
So first of all, note how we use except exception as the moment we do that, the moment we add as 'E',
we can refer to the exception object within the accept block using the identifier 'e' inside the brackets
we try to print 'e', so let's see what that does.

def return_bigger(a, b)
  try:
    if b > a:
      return b
    else:
      return a
  except Exception as e:
    print(e)
    return None

return_bigger(5, 'b')
out: '>' not supported between insances of 'str' and 'int'
None

You can see that when we try to print the exception object, we get some detailed info about what the
problem was.
That's because by default the exception class implements a version of the double underscore str double
underscore method common to all objects.
Instead of showing the identifier of the object in the memory, we can find a meaningful error message.
In this case, we can see that it's not possible to compare a string with an integer exceptions in python
form a class hierarchy.

For instance, we can try to print the following statement.
So in a new cell you're going to do for subclass in Baseexception subclasses
print subclass name like this you can see all the subclasses that directly inherit from the base exception
class and if you try one of the subclasses like exception for example.

for subclass in BaseException.__subclasses__():
  print(subclass.__name__)
output:
Exception
GeneratorExit
SystemExit
KeyboardInterrupt
CancelledError
DebuggerInitializationError

for subclass in Exception.__subclasses__():
  print(subclass.__name__)
output:
StopAsyncIteration
StopIteration
ImportError
OSError
EOFError
RuntimeError
NameError
AttributeError
SyntaxError
LookupError

There are a lot of classes that directly inherit from exception.
Each exception class that inherits from BaseException has a property named Oryx.
It's a tuple which contains all the arguments passed to the constructor.
For example, try raise exception except exception as e print e arcs.

try:
  raise Exception
except Exception as e:
  print(e.args)    

output: ()

In this simple case, the code only raises a general exception when we try to print the property of
the exception object.
You can see that it's actually empty.
This means that no argument was passed to the class constructor.
Let's try a different version now.
So this time we're going to do something like this and add the following element here.

try:
  raise Exception('i do not like it')
except Exception as e:
  print(e.args)    

output: ('i do not like it',)

Note the new syntax that we use now here.
After the keyword rise and the exception class, we provided a pair of brackets and we put a string
inside.
If this syntax looks familiar to you, you are right.
We're actually invoking the constructor of the exception class.
With one argument exception classes in Python are constructed in such a way that you can pass even more
arguments to the exception constructor so we can do the following in the new cell.

try:
  raise Exception('i do not like it', 'in fact, i do not like it at all')
except Exception as e:
  print(e.args)    

output: ('i do not like it', 'in fact, i do not like it at all')

And you can see both of them here.

All of the arguments passed to the constructor are added to the property.

This feature is typically used to pass some details about why a given exception is raised.

In fact, you can easily see that Python adds some arguments when it raises exceptions automatically

for you.

So take a look at this new cell we are going to do try one divided by zero except exception as E and

now print e asks.

Here, Python raises an exception when you try to divide by zero.

And as you can see, Python added a short explanation to the tuple.

Another example could be the following.

Try five.

Less than a except exception as E and print e asks again and again.

Python puts a sort of explanation into the double.
