Exceptions - syntax errors
-----------------------
you can use the default except block to catch any sort of exception:

try:
  # your code
except:
  # any exception
However, there is one special exception type: SyntaxError. You should pay attention to how it works.

If you raise a SyntaxError manually, then you can catch it in the except block just fine:

try:
  raise SyntaxError
except:
  print('Got it!') # SyntaxError is caught here

However, if you make a syntax error in the try block and Python automatically raises a SyntaxError for you, then you cannot catch it:

try:
  5:4 # this line generates a SyntaxError
except:
  print('Got it!') # SyntaxError is NOT caught here

================
try/except with else
------------------
try: 
    value = int(input('enter an int: '))
    print(1/value)
except:
    print('something went wrong')
else:
    print('everything is perfect')

if we provide 0 - first branch will be printed
if we provide any other value - second branch will be executed

==========
finally
----------
Finally, Python offers an additional keyword that can be used with try accept blocks.
Finally, it must be the very last branch of the code intended for handling exceptions.
It must appear even after the ls block ls and finally are not dependent on each other.
You can have both of them.

You try block only one of the two or none at all.
The general rule is that the final block is executed always, no matter if an exception is raised or
not, no matter if a raised exception is handled or not.
Then finally, BLOCK will always execute in real life programming.
Finally, blocks are typically used when we work with some external resources, such as databases or
text files.

For instance, when we want to retrieve some data from a database, we first need to open a connection
to the database, then retrieve the data and then close the connection.
It's then a good idea to close the connection in a final block, no matter if our code succeeds or not.
No matter if we manage to retrieve the data or we get a connection error, we should always close the
connection to the database to limit the amount of memory that the machine uses.

So I'm going to give you a simple example of finally using a division error.
We are going to define a function named get inverse.
And we are trying to return the inverse of X.

def get_inverse(x):
  try:
    return 1 / x
  except ZeroDivisionError:
    return None
  finally:
    print('i am always printed')

print(get_inverse(5))

output1: i am always printed
0.2

print(get_inverse(0))
output1: i am always printed
None

Now we know that this may produce some errors, so we are going to accept zero to vision error.
In which case we return none.
And we are going to add a final block here and we will print.
Run the cell and now in the new cell we are going to do print, get in verse five, which is all good.
And you can see 'I am always printed' to the output and now with an exception, if we provide the number
zero, you can also see 'I am always printed'.

So note that in both situations the final block is executed before the function finishes and returns
the actual number.
In the second case we get a zero division error and we return none.
But before that happens, in both cases we see I am always printed to the output because of the final
block.

==========
raise exception
----------
So far we've only seen examples where Python raises exceptions for us when we try to divide by zero.
Python automatically erased an exception when we tried to access a non-existing array index.
Python raised an exception. All of that happened automatically for us.

Python allows you to raise exceptions on your own.
Raising exceptions on your own is typically used in two types of situations.
When you write tests to check your programs, you can raise exceptions to verify how your piece of code
will behave.
If, during the execution of your program, Python suddenly raises a real exception.

The second use case is when you want to make another part of the program responsible for handling the
exception.
This can be very useful in larger applications.
To raise an exception, we use the keyword to raise, followed by the name of the exception.

For example, let's say that we want to define a function that returns the bigger number of two.
And here, first of all, we want to check, if not, is instance a int or not is instance.
Be int we going to raise value error?
Then if be larger than a return, be else return a run the cell.

def returb_bigger(a, b)
  if not isinstance(a, int) or not isinstance(b, int)

And now in the new cell we are going to print return Baker five three and we get five in the output.

And a second example five and something strange be and you can see a value error.

So here in the return bigger function, we assume that both arguments will be of type integer.

We checked out at the very beginning of the function.

If at least one of the numbers is not an integer, we manually raise a value error here by using the

race keyword.

You can see how that works when we try to invoke the function with an invalid argument.

Right.

There's also another usage of the word res.

You can use it without any exception name inside the except branch.

This instruction will then re res the very same exception as currently handled.

Take a look in a new cell.

I'm going to do the following.

Def return reverse of x.

Try.

Return one divided by x.

Except print.

Something went wrong.

We're on the cell.

So this is a version without the keyword race.

And if we do return reverse of zero.

When we run the coach, you can see that for argument zero.

We simply see something went wrong printed.

What happens when we add the race keywords?

So let's copy paste that into a new cell like this.

And here we are just going to add to raise run the cell again.

And now if you try the very same invocation.

This time you can see something went wrong in the output, but we can also see that the zero division

error was raised again.

This programming technique is sometimes used when you only want to handle an exception partially, and

then you want to raise the exception again.

So that's another part of the code finishes the exception handling.
